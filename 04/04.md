### 메모리 계층 (Memory Hierarchy)
- 메모리 계층은 저장 장치의 속도, 용량, 접근 시간에 따라 계층화된 구조를 의미합니다. 일반적으로 속도가 빠를수록 용량이 작고, 비용이 높습니다.
    1. 레지스터 (Register): CPU 내부에 위치한 가장 빠른 메모리. 용량이 매우 작고 즉각적인 데이터 처리를 위해 사용.
    2. 캐시 메모리 (Cache Memory): CPU와 메인 메모리 사이에 위치해 자주 사용하는 데이터를 빠르게 접근하도록 돕는 메모리.
    3. 메인 메모리 (RAM): 프로그램과 데이터를 실행 중에 보관하는 휘발성 메모리.
    4. 보조 저장 장치 (Secondary Storage): HDD, SSD와 같은 장기 저장 장치.
    5. 아카이브 스토리지 (Tertiary Storage): 백업과 장기 보관을 위한 저장 장치, 예: 테이프 드라이브.
    
### 메모리 할당 방식 (Memory Allocation Methods)
- 메모리 할당은 운영체제가 프로그램 실행을 위해 메모리를 분배하는 방식입니다.
    - 고정 분할 할당 (Fixed Partition Allocation)
        - 메모리를 미리 여러 개의 고정된 크기로 나누어 프로세스가 들어올 때 해당 크기만큼 할당하는 방식입니다.
        - 메모리를 여러 개의 정해진 크기로 분할.
        - 각 프로세스는 적합한 크기의 분할에 할당됨.
        - 분할 크기는 시스템 부팅 시 결정.
    - 장점:
        1. 구현이 간단하고, 할당과 해제가 빠름.
        2. 관리가 용이하고, 내부 단편화 발생 여부를 쉽게 파악 가능.
    - 단점:
        1. 내부 단편화 (Internal Fragmentation): 프로세스 크기가 분할 크기보다 작으면 남는 공간이 낭비됨.
        2. 비효율적 메모리 활용: 큰 프로그램은 작은 분할에 들어갈 수 없어 실행이 불가능함.

    - 가변 분할 할당 (Variable Partition Allocation)
        - 프로세스가 필요로 하는 메모리 크기만큼 동적으로 할당하는 방식입니다.
        - 프로세스의 크기에 따라 메모리 공간을 유동적으로 할당.
        - 메모리 해제 시 해당 공간이 비어 있게 됨.  
    - 장점:
        1. 메모리 효율성 높음: 필요한 만큼만 할당하므로 내부 단편화가 줄어듦.
        2. 여러 크기의 프로그램을 유연하게 실행 가능.
    - 단점:
        1. 외부 단편화 (External Fragmentation): 프로세스가 해제된 후 비연속적인 공간이 남아 새로운 프로세스를 할당하지 못하는 현상 발생.
        2. 메모리 관리 부담 증가: 연속된 빈 공간을 찾아야 하는 오버헤드가 발생.

### 스와핑 (Swapping)
- 스와핑은 메모리 관리를 위해 프로세스를 메모리와 디스크 간에 교환하는 과정입니다.
- 실행 중인 프로세스를 메모리에서 디스크로 이동시키고, 다시 필요할 때 메모리로 불러오는 작업.
- 장점: 다중 프로그래밍 환경에서 메모리를 효율적으로 활용.
- 단점: 디스크 접근 속도가 느려 성능 저하(스레싱 현상) 발생 가능.


### 외부 단편화 (External Fragmentation)
- 외부 단편화는 메모리의 총 빈 공간은 충분하지만, 연속된 공간이 없어 새로운 프로세스를 할당하지 못하는 현상을 의미합니다.

- 원인: 메모리를 할당하고 해제하는 과정에서 비연속적인 작은 조각들이 남음.
- 해결 방법:
    1. 압축 (Compaction): 메모리의 조각난 공간을 한곳으로 모으는 방법.
    2. 페이징 (Paging): 메모리를 고정 크기 블록으로 나누어 불연속적인 할당을 허용.
    3. 세그멘테이션 (Segmentation): 논리적 단위로 메모리를 나누어 관리.


### 요구 페이징
- 요구 페이징은 프로세스의 전체 메모리를 한꺼번에 적재하지 않고, 필요할 때(page fault 발생 시)만 메모리에 페이지를 불러오는 기법입니다.
- 프로그램 실행 시 처음에는 최소한의 페이지만 메모리에 적재.
- 페이지에 접근할 때 해당 페이지가 메모리에 없으면 페이지 폴트(Page Fault) 발생.
- 페이지 폴트 시 디스크에서 해당 페이지를 메모리로 불러옴.

- 장점:
    - 메모리 사용량 절감.
    - 다중 프로그래밍 효율성 증가.
- 단점:
    - 페이지 폴트 시 속도 저하.
    - 페이지 교체 정책이 적절하지 않으면 성능 저하와 스래싱 발생.

### 페이지 교체 정책
- 페이지 폴트 발생 시, 메모리에 새로운 페이지를 적재할 공간이 없을 때 어떤 페이지를 내보낼지 결정하는 방법입니다.

    - 선입선출 (FIFO: First In, First Out)
        - 가장 먼저 메모리에 들어온 페이지를 먼저 내보내는 방식.
        - 장점: 구현이 간단함.
        - 단점: 오래된 페이지가 자주 사용 중인 페이지일 수도 있어 성능 저하 가능.
        - 예: 페이지 프레임이 3개일 때, [1, 2, 3, 1, 4, 5] 순서로 접근하면, 1이 먼저 들어와서 1이 먼저 교체됨.

    - 최적 페이지 교체 (Optimal Page Replacement)
        - 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체하는 방식.
        - 장점: 페이지 폴트를 최소화.
        - 단점: 미래 접근을 예측해야 하므로 실제 구현이 불가능함(이론적 방법).
        - 예: [1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5]에서, 5가 들어올 때 3이 가장 나중에 사용되므로 3을 교체.

    - LRU (Least Recently Used)
        - 가장 오랫동안 사용되지 않은 페이지를 교체하는 방식.
        - 장점: 최근에 사용된 페이지를 유지해 성능 개선.
        - 단점: 시간과 공간 오버헤드 발생(사용 기록 유지 필요).
        - 예: [1, 2, 3, 1, 4, 5]에서, 5가 들어올 때 가장 오랫동안 사용되지 않은 2를 교체.

### 스래싱(thrashing)
- 스래싱은 페이지 폴트가 과도하게 발생해 CPU가 페이지 교체 작업에만 집중하고, 실제 작업은 거의 수행되지 않는 상태를 의미합니다.
- 메모리보다 많은 프로세스를 동시에 실행.
- 적절한 페이지 교체 정책 부재.
- 페이지 프레임 수 부족.

- 해결 방법:
    - 워크킹 셋 (Working Set): 프로세스가 일정 기간 동안 필요로 하는 페이지 수를 기준으로 메모리 할당.
    - 페이지 부하 제어 (Page Load Control): 페이지 폴트율을 모니터링해 메모리 부담을 조정.
    - 프로세스 수 조정: 실행 중인 프로세스 수를 줄여 메모리 여유 확보.